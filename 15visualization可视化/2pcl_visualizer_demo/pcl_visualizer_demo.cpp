#include <iostream>

#include <boost/thread/thread.hpp>
#include <pcl/common/common_headers.h>
#include <pcl/features/normal_3d.h>
#include <pcl/io/pcd_io.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/console/parse.h>

// --------------
// -----Help-----
// --------------
void printUsage(const char *progName)
{
    std::cout << "\n\nUsage: " << progName << " [options]\n\n"
              << "Options:\n"
              << "-------------------------------------------\n"
              << "-h           this help\n"
              << "-s           Simple visualisation example\n"
              << "-r           RGB colour visualisation example\n"
              << "-c           Custom colour visualisation example\n"
              << "-n           Normals visualisation example\n"
              << "-a           Shapes visualisation example\n"
              << "-v           Viewports example\n"
              << "-i           Interaction Customization example\n"
              << "\n\n";
}
/************************************************************************************************************
/*****************************可视化单个点云：应用PCL Visualizer可视化类显示单个具有XYZ信息的点云****************/
/************************************************************************************************************/

//simpleVis函数实现最基本的点云可视化操作，
boost::shared_ptr<pcl::visualization::PCLVisualizer> simpleVis(pcl::PointCloud<pcl::PointXYZ>::ConstPtr cloud)
{
    
}
/*****************************可视化点云颜色特征******************************************************/
/**************************************************************************************************
 多数情况下点云显示不采用简单的XYZ类型，常用的点云类型是XYZRGB点，包含颜色数据，除此之外，还可以给指定的点云定制颜色
  以示得点云在视窗中比较容易区分。点赋予不同的颜色表征其对应的Z轴值不同，PCL Visualizer可根据所存储的颜色数据为点云
  赋色， 比如许多设备kinect可以获取带有RGB数据的点云，PCL Vizualizer可视化类可使用这种颜色数据为点云着色，rgbVis函数中的代码
用于完成这种操作。
  ***************************************************************************************************/
/**************************************************************************
   与前面的示例相比点云的类型发生了变化，这里使用的点云带有RGB数据的属性字段，
  ****************************************************************************/
boost::shared_ptr<pcl::visualization::PCLVisualizer> rgbVis(pcl::PointCloud<pcl::PointXYZRGB>::ConstPtr cloud)
{
    // --------------------------------------------
    // -----Open 3D viewer and add point cloud-----
    // --------------------------------------------
   
}
/******************可视化点云自定义颜色特征**********************************************************/
/****************************************************************************************************
 演示怎样给点云着上单独的一种颜色，可以利用该技术给指定的点云着色，以区别其他的点云，
 *****************************************************************************************************/
//点云类型为XYZ类型，customColourVis函数将点云赋值为绿色，
boost::shared_ptr<pcl::visualization::PCLVisualizer> customColourVis(pcl::PointCloud<pcl::PointXYZ>::ConstPtr cloud)
{
   
}

//*******************可视化点云法线和其他特征*************************************************/
/*********************************************************************************************
  显示法线是理解点云的一个重要步骤，点云法线特征是非常重要的基础特征，PCL visualizer可视化类可用于绘制法线，
   也可以绘制表征点云的其他特征，比如主曲率和几何特征，normalsVis函数中演示了如何实现点云的法线，
  ***********************************************************************************************/
boost::shared_ptr<pcl::visualization::PCLVisualizer> normalsVis(
    pcl::PointCloud<pcl::PointXYZRGB>::ConstPtr cloud, pcl::PointCloud<pcl::Normal>::ConstPtr normals)
{
    
}

//*****************绘制普通形状************************************************//
/**************************************************************************************************************
  PCL visualizer可视化类允许用户在视窗中绘制一般图元，这个类常用于显示点云处理算法的可视化结果，例如 通过可视化球体
  包围聚类得到的点云集以显示聚类结果，shapesVis函数用于实现添加形状到视窗中，添加了四种形状：从点云中的一个点到最后一个点
  之间的连线，原点所在的平面，以点云中第一个点为中心的球体，沿Y轴的椎体
 *************************************************************************************************************/
boost::shared_ptr<pcl::visualization::PCLVisualizer> shapesVis(pcl::PointCloud<pcl::PointXYZRGB>::ConstPtr cloud)
{
   
}
/******************************************************************************************
 多视角显示：PCL  visealizer可视化类允许用户通过不同的窗口（Viewport）绘制多个点云这样方便对点云比较
 viewportsVis函数演示如何用多视角来显示点云计算法线的方法结果对比
******************************************************************************************/

boost::shared_ptr<pcl::visualization::PCLVisualizer> viewportsVis(
    pcl::PointCloud<pcl::PointXYZRGB>::ConstPtr cloud, pcl::PointCloud<pcl::Normal>::ConstPtr normals1, pcl::PointCloud<pcl::Normal>::ConstPtr normals2)
{
    
}
/*******************************************************************************************************
 这里是处理鼠标事件的函数，每次相应鼠标时间都会回电函数，需要从event实例提取事件信息，本例中查找鼠标左键的释放事件
 每次响应这种事件都会在鼠标按下的位置上生成一个文本标签。
 *********************************************************************************************************/

unsigned int text_id = 0;
void keyboardEventOccurred(const pcl::visualization::KeyboardEvent &event,
                           void *viewer_void)
{
   
/********************************************************************************************
 键盘事件 我们按下哪个按键  如果按下r健   则删除前面鼠标所产生的文本标签，需要注意的是，当按下R键时 3D相机仍然会重置
  所以在PCL中视窗中注册事件响应回调函数，不会覆盖其他成员对同一事件的响应
**************************************************************************************************/
void mouseEventOccurred(const pcl::visualization::MouseEvent &event,
                        void *viewer_void)
{
    
}

/******************自定义交互*****************************************************************************/
/******************************************************************************************************
  多数情况下，默认的鼠标和键盘交互设置不能满足用户的需求，用户想扩展函数的某一些功能，  比如按下键盘时保存点云的信息，
  或者通过鼠标确定点云的位置   interactionCustomizationVis函数进行演示如何捕捉鼠标和键盘事件，在窗口点击，将会显示
  一个2D的文本标签，按下r健出去文本
  ******************************************************************************************************/

boost::shared_ptr<pcl::visualization::PCLVisualizer> interactionCustomizationVis()
{
    
}

// --------------
// -----Main-----
// --------------
int main(int argc, char **argv)
{
    
}